# 03-1 소스 코드와 명령어

## 고급 언어와 저급 언어

**고급 언어** : 사람이 이해하고 작성하기 쉽게 만들어진 언어, 컴퓨터는 이해하지 못한다.  
**저급 언어** : 컴퓨터가 직접 이해하고 실행할 수 있는 언어  
컴퓨터가 이해하고 실행할 수 있는 언어는 오직 저급 언어뿐이므로, 고급 언어로 작성된 소스코드는 반드시 저급 언어, 즉 명령어로 변환되어야 한다.

저급언어에는 기계어와 어셈블리어가 있다.  
**기계어** : 0과 1의 명령어 비트로 이루어진 언어

<img width="413" alt="image" src="https://github.com/BinaryHyeok/TIL/assets/94176133/21516484-a44b-43eb-ae23-690909ee3ef3">

기계어는 오로지 컴퓨터만을 위해 만들어진 언어이기 때문에 사람이 읽으면 그 의미를 이해하기 어렵다. 그래서 등장한 언어가 **어셈블리어**이다.  
**어셈블리어**는 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어이다.

<img width="604" alt="image" src="https://github.com/BinaryHyeok/TIL/assets/94176133/1a73e93b-b70f-48b0-b958-d9ece56f5df2">

어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 즉 프로그램이 어떤 절차로 작동하는 지 가장 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있다.

<br>

## 컴파일 언어와 인터프리터 언어

고급 언어로 작성된 코드는 저급 언어로 변환되어 실행되야 한다. 저급 언어로 변환되는 방식에는 크게 두 가지, **컴파일** 방식과 **인터프리터** 방식이 있다. 컴파일 방식으로 작동하는 프로그래밍 언어를 **컴파일 언어**, 인터프리트 방식으로 작동되는 프로그래밍 언어를 **인터프리터 언어**라고 한다.

### 컴파일 언어

**컴파일 언어**는 컴파일러에 의해 소스 코드 전체가 저급언어로 변환되어 실행되는 고급 언어이다.  
컴파일 언어로 작성된 소스 코드는 코드 전체가 저급 언어로 변환되는 과정을 거치는데, 이것을 **컴파일** 이라고 한다.  
컴파을을 수행 해주는 도구를 **컴파일러**라고 한다. 컴파일러는 소스 코드에 문법적인 오류, 실행 가능한 코드, 실행하는데 불필요한 코드 등을 따지며 전체를 컴파일 하게 되는데, 만약 소스 코드내에서 오류가 하나라도 발견되게 된다면 해당 소스 코드는 컴파일에 실패하게 된다.

컴파일에 성공하게 되면 개발자가 작성한 코드는 저급언어로 변환되고, 이렇게 컴파일러를 통해 변환된 저급 언어로 된 코드를 **목적 코드**라고 한다.

### 인터프리터 언어

**인터프리터 언어**는 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어이다.  
소스 코드 전체가 저급 언어로 변환되는 컴파일 언어와 달리, 인터프리터 언어는 소스 코드를 한 줄씩 차례로 실행합니다. 그리고 이러한 방식으로 저급 언어로 변환하여 실행해 주는 도구를 **인터프리터**라고 한다.  
소스 코드를 한 줄씩 실행하므로 N번째 줄에 문법 오류가 있더라고 N-1번째 줄 까지는 올바르게 실행이 된다.

일반적으로 인터프리터 언어는 한 줄씩 저급 언어로 해석하며 실행해야 되므로, 컴파일 언어보다 느리다.

> 하나의 프로그래밍 언어가 반드시 한가지 방식으로 작동하지는 않는다. 한가지 방식을 사용하여 저급 언어로 변환하는 언어도 있으나, 지금의 많은 프로그래밍 언어는 컴파일, 인터프리트 방식 두 가지 모두 사용한다.

<br>

# 03-2 명령어의 구조

## 연산 코드와 오퍼랜드

**명령어** : 연산 코드 + 오퍼랜드  
**연산 코드** : 명령어가 수행할 연산, **연산자**  
**오퍼랜드** : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치, **피연산자**  
**연산 코드 필드** : 연산 코드가 담기는 영역  
**오퍼랜드 필드** : 오퍼랜드가 담기는 영역

기계어와 어셈블리어 또한 명령어이기 때문에 연산 코드와 오퍼랜드로 구성되어 있다.

<img width="629" alt="image" src="https://github.com/BinaryHyeok/TIL/assets/94176133/bf46f326-07bd-41d1-b5b3-65edd7d53c41">

<br>

### 오퍼랜드

오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올수 있지만, 많은 경우 데이터를 직접 명시하기 보다는 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다. 그래서 오퍼랜드 필드를 **주소 필드**라고 부르기도 한다.  
**0-주소 명령어** : 오퍼랜드가 하나도 없는 명령어  
**1-주소 명령어** : 오퍼랜드가 하나인 명령어  
**2-주소 명령어** : 오퍼랜드가 두 개인 명령어
**3-주소 명령어** : 오퍼랜드가 세 개인 명령어

### 연산 코드

연산 코드 종류는 많지만, 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다.

1. 데이터 전송
   - MOVE : 데이터 전송
   - STORE : 메모리 저장
   - LOAD(FETCH) : 메모리에서 CPU로 데이터 가져오기
   - PUSH : 스택에 데이터 저장
   - POP : 스택에서 데이터 꺼내기
2. 산술/논리 연산
   - ADD / SUBTRACT / MULTIPLY / DIVIDE : 사칙연산 수행
   - INCREMENT / DECREMENT : 오퍼랜드에 +1 / -1
   - AND / OR / NOT : AND, OR, NOT 연산 수행
   - COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값 비교
3. 제어 흐름 변경
   - JUMP : 특정 주소로 실행 순서를 옮기기
   - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서 옮기기
   - HALT : 프로그램의 실행 멈추기
   - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서 옮기기
   - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가기
4. 입출력 제어
   - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽기
   - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 쓰기
   - START IO : 입출력 장치를 시작
   - TEST IO : 입출력 장치의 상태를 확인

<br>

## 주소 지정 방식

명령어가 n비트로 구성되어 있고, 그 중 연산 코드 필드가 m비트다. 이때 오퍼랜드 필드는 1-주소 명령어라고 할 지라도 오퍼랜드 필드의 길이는 n-m비트가 최대 값이다. 2-주소 명령어, 3-주소 명령어라면 오퍼랜드 필드의 크기는 더욱 작아질 것이다.

ex) 명령어가 16비트, 연산 코드 필드가 4비트인 3-주소 명령어라면 총 오퍼랜드 필드는 16 - 4 = 12 만큼의 영역을 가지게 되고, 3-주소 명령어이므로 오퍼랜드 필드당 4비트가 사용이 가능하다. 따라서 하나의 오퍼랜드 필드는 2⁴개의 정보를 나타낼 수 있다.

하지만, 오퍼랜드 필드에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다. 메모리 주소뿐만 아니라 레지스터 이름을 명시해도, 정보의 가짓수는 레지스터가 저장할 수 있는 공간만큼 커진다.

연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소**라고 한다.

**주소 지정 방식** : 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법, 즉 유효 주소를 찾는 방법이다.

### 즉시 주소 지정 방식

**즉시 주소 지정 방식**은 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식. 이러한 방식은 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 떄문에 빠르다.

### 직접 주소 지정 방식

**직접 주소 지정 방식**은 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식. 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수 만큼 줄어들었다.

즉, 오퍼랜드 필드의 길이가 연산 코드의 길이만틈 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

### 간접 주소 지정 방식

**간접 주소 지정 방식**은 유효 주소의 주소를 오퍼랜드 필드에 명시한다. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 늘어난 대신 두번의 메모리 접근이 필요하여 일반적으로 느린 방식이다.

### 레지스터 주소 지정 방식

**레지스터 주소 지정 방식**은 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법.

일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. 따라서 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다. 하지만, 직접 주소 지정 방식과 비슷하게 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

### 레지스터 간접 주소 지정 방식

**레지스터 간접 주소 지정 방식**은 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법.

유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 장점이 있다. 그리고, 레지스터에 접근하는 것이 메모리에 접근하는 것보다 빠르므로 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠르다.

**주소 지정 방식** : 연산에 사용할 데이터를 찾는 방법  
**유효 주소** : 연산에 사용할 데이터가 저장되 위치

- 즉시 주소 지정 방식 : 연산에 사용할 데이터
- 직접 주소 지정 방식 : 유효 주소(메모리 주소)
- 간접 주소 지정 방식 : 유효 주소의 주소
- 레지스터 주소 지정 방식 : 유효 주소(레지스터 이름)
- 레지스터 간접 주소 지정 방식 : 유효 주소(메모리 주소)를 저장한 레지스터
