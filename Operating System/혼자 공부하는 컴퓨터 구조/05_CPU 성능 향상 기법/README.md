# 05-1 빠른 CPU를 위한 설계 기법

## 클럭

클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 것이고, 다른 부품들도 그에 맞춰서 더 빠르게 작동할 것이다.  
**클럭 속도**는 헤르츠(Hz)단위로 측정한다. 이는 1초에 클럭이 몇 번 반복되는지를 나타낸다.  
만약 클럭이 1초에 한 번이라면 CPU 클럭 속도는 1Hz인 것이고, 클럭이 1초에 100번 반복되면 CPU 클럭 속도는 100Hz 이다.

## 코어와 멀티코어

클럭 속도를 높이는 방법 외에도 CPU의 성능을 높이는 방법이 존재하는데, 코어와 스레드 수를 늘리는 방법이 있다.

CPU의 정의로 알고 있던 '명령어를 실행하는 부품'은 **코어**라는 용어로 사용된다.  
코어를 여러 개 포함하고 있는 CPU를 **멀티코어 CPU** 또는 **멀티코어 프로세서**라고 부른다.  
코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않으며, 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없다.

## 스레드와 멀티스레드

스레드는 CPU에서 사용되는 **하드웨어적 스레드**, 프로그램에서 사용되는 **소프트웨어적 스레드**가 있다.

### 하드웨어적 스레드

스레드를 하드웨어적으로 정의하면 '하나의 코어가 동시에 처리하는 명령어 단위'를 의미한다. 지금까지의 CPU는 1코어 1스레드로, 명령어를 실행하는 부품이 하나 있고, 한 번에 하나싞 명령어를 실행하는 CPU를 가정하였다.

반면, 여러 스레드를 지원하는 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있다.  
예를들어, 2코어 4스레드 CPU는 명령어를 실행하는 부품을 두 개 포함하고, 한 번에 네 개의 명령어를 처리할 수 있는 CPU를 뜻한다.

하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 **멀티스레드 프로세서** 또는 **멀티스레드 CPU**라고 한다.

### 소프트웨어적 스레드

스레드를 소프트웨어 적으로 정의하면 '하나의 프로그램에서 독립적으로 실행되는 단위'를 의미한다.

정리하면, 하드웨어적 스레드는 '하나의 코어가 동시에 처리하는 명령어 단위'를 의미하고, 소프트웨어적 정의는 '하나의 프로그램에서 독립적으로 실행되는 단위'를 의미한다.
한 번에 하나씩 명령어를 처리하는 1코어 1스레드 CPU도 소프트웨어 스레드를 수십 개 실행할 수 있다. 1코어 1스레드 CPU로도 프로그램의 여러 부분을 동시에 실행할 수 있는 것이다.

### 멀티스레드 프로세서

멀티스레드 프로세서는 하나의 코어로 여러 명령어를 동시에 처리하는 CPU  
**멀티스레드 프로게서**에서 큰 핵심은 레지스터이다. 하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스택 포인터, 데이터 버퍼레지스터, 데이터 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개 가지고 있으면 된다.

하드웨어 스레드를 이용하면 하나의 코어로도 여러 명령어를 동시에 처리할 수 있는데, 그러나 메모리 속 프로그램 입장에서는 하드웨어 스레드는 마치 '한 번에 하나의 명령어를 처리하는 CPU'와 같다. 프로그램 입장에서는 한 번에 하나의 명령어를 처리하는 CPU가 여러개 있는 것 처럼 보이는 것이다. 그래서 하드웨어 스레드를 **논리 프로세서**라고도 한다.

**코어**는 명령어를 실행할 수 있는 '하드웨어 부품'  
**스레드**는 명령어를 실행하는 단위  
**멀티코어 프로세서**는 명령어를 실행할 수 있는 하드웨어 부품이 CPU안에 두 개 이상 있는 CPU  
**멀티스레드 프로세서**는 하나의 코어로 여러개의 명령어를 동시에 실행할 수 있는 CPU

<br>

# 05-2 명령어 병렬 처리 기법

**명령어 병렬 처리 기법** : 명령어를 동시에 처리하여 CPU를 작동시키는 기법  
대표적인 명령어 병렬 처리 기법에는 **명령어 파이프 라이닝**, **슈퍼스칼라**, **비순차적 명령어 처리**가 있다.

## 명령어 파이프 라인

명령어 처리 과정을 클럭 단위로 나누어 보면 다음과 같이 나눌 수 있다.

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장

중요한 점은 CPU는 '각 단계를 동시에 실행할 수 있다'라는 것이다. 예를 들어 CPU는 한 명령어를 '인출'하는 동안에는 다른 명령어를 '실행'할 수 있고, '실행'하는 동안에는 다른 명령어를 '저장'할 수 있는 것이다.

이렇게 명령어들을 **명령어 파이프라인**에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝**이라고 한다.

파이프라이닝이 높은 성능을 가져오기도 하지만 성능 향상에 실패하는 경우도 있는데 이러한 상황을 **파이프라인 위험**이라고 부른다.

파이프라인 위험

- 데이터 위험
- 제어 위험
- 구조적 위험

### 데이터 위험

'데이터 의존성'에 의해 발생한다. 모든 명령어를 동시에 처리할 수 없고, 어떤 명령어는 이전 명령어를 끝까지 실행해야만 실행할 수 있다.

ex)  
명령어 1 : R1 ← R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장  
명령어 2 : R4 ← R1 + R5 // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장  
이러한 경우 명령어 1이 수행되야 명령어 2가 수행이 가능하다. 만약 명령어 1 실행이 끝나기 전에 명령어 2를 인출하면 R1에 R2 + R3 값이 저장되기 전에 명령어2의 R1 + R5가 수행이 될 것이다.

이처럼 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 **데이터 위험**이라고 한다.

### 제어 위험

'프로그램 카운터의 갑작스러운 변화'에 의해 발생한다. 기본적으로 프로그램 카운터는 '현재 실행 중인 명령어의 다음 주소'로 갱신된다. 하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이던 명령어들은 쓸모 없어진다. 이를 **제어 위험**이라고 한다.

이러한 문제를 해결하기 위하여 사용하는 기술 중 하나가 **분기 예측**이다. 분기 예측은 프로글매이 어디로 분기할 지 미리 예측한 후 그 주소를 인출하는 기술이다.

### 구조적 위험

명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생한다. 구조적 위험은 **자원 위험**이라고도 부른다.

## 슈퍼스칼라

파이프라이닝은 단일 파이프라인으로도 구현이 가능하지만 대부분의 CPU는 여러 개의 파이프라인을 이용한다. CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 **슈퍼스칼라**라고 한다.

슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 **슈퍼스칼라 프로세서** 또는 슈퍼스칼라 CPU라고 한다. 슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출하고, 실행할 수 있다. 멀티스레드 프로세서는 한 번에 여러 명령어를 인출하고, 해석하고, 실행할 수 있기 때문에 슈퍼스칼라 구조를 사용할 수 있다.

이론적으로는 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만, 파이프라인 위험 등의 예상치 못한 문제가 있어 실제로는 반드시 파이프라인 개수에 비례하여 빨라지지는 않는다. 이 때문에 슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 한다.

## 비순차적 명령어 처리

비순차적 명령어 처리 기법은 명령어들을 순차적으로 실행하지 않는 기법이다. 명령어들 중 이전 명령어를 끝까지 실행해야 실행할 수 있는 명령어가 있다. 이러한 명령어들은 데이터 의존성에 의하여 순차적으로 실행되야 결과를 보장 할 수 있다.  
하지만 이렇게 순차적으로 실행하게 된다면 명령어 파이프라이닝을 할 수 없어 비효율적이게 된다.  
명령어들 중에서 데이터 의존성이 전혀 없는, 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들이 있는데, 이러한 명령어들을 먼저 실행하여 순차적으로 명령어를 처리하는 것보다 더 효율적으로 처리하고, 명령어 파이프라인이 멈추는 것을 방지할 수 있다. 이러한 기법을 **비순차적 명령어 처리 기법**이라고 한다.

비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떠한 것이 있는지 판단할 수 있어야 한다.

<br>

# 05-3 CISC와 RISC

## 명령어 집합

CPU가 이해할 수 있는 명령어들의 모음을 **명령어 집합** 또는 **명령어 집합 구조**(ISA)라고 한다. 즉 CPU마다 ISA가 다를 수 있다.  
ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻이고, 명령어가 달라지면 어셈블리어도 달라진다. 다시말해서 같은 소스 코드로 만들어진 프로그램이라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다는 뜻이다.

ISA가 같은 CPU끼리는 서로의 명령어를 이해할 수 있지만, ISA가 다르면 서로의 명령어를 이해하지 못한다. 이런 점에서 ISA는 일종의 CPU의 언어이다.

또한 ISA가 다르면 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라지게 되고, 이는 CPU 하드웨서 설계에도 영향을 미친다.  
명령어 병렬 처리 기법또한 ISA의 영향을 받는다.

## CISC

CISC는 Complex Instruction Set Computer의 약자이다. 이를 해석하면 '복잡한 명령어 집합을 활요하는 컴퓨터'를 의미한다. CISC는 다양한 명령어를 활용하는 CPU 설계 방식이며, x86, x86-64는 대표적인 CISC 기반의 ISA이다.

CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용한다.  
다양하고 강력한 명령어를 활용하므로, 적은 수의 명령어로도 프로그램을 실행할 수있다. 이는 실행파일의 크기도 더 작다는 것을 뜻한다.

이러한 장점 덕분에 CISC는 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았다. '적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다'라는 점은 메모리 공간을 절약할 수 있다는 장점이 있기 떄문이다.

하지만 치명적인 단점도 존재하는데, 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않았다. 그리고 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 한다.

CISC가 활용하는 명령어는 명령어 수행 시간이 길고 가지각색이기 때문에 파이프라인이 효율적으로 명령어 처리할 수 없다. 규격화되지 않는 명령어가 파이프라이닝을 어렵게 만드는 셈이다. 게다가 대다수의 복잡한 명령어는 그 사용빈도가 낮다.

정리하면, CISC 명령어 집합은 복잡하고 다양한 기능을 제공하기에 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어렵다. 그리고 대다수의 복잡한 명령어는 그 사용 빈도가 낮다. 이러한 이유로 CISC 기반 CPU는 성장에 한계가 있다.

## RISC

CISC의 한계가 준 교훈은 다음과 같다.

1. 빠른 처리를 위해 명령어 파이프라인을 활용해야 한다. 원할한 파이프라이닝을 위해 '명령어 길이와 수행 시간이 짧고 규격화'되어 있어야 한다.
2. 어차피 자주 쓰이는 명령어만 줄곧 사용된다. 복잡한 기능을 지원하는 명령어를 추가하기보다는 '자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것'이 중요하다.

이러한 원칙 하에 등장한 것이 **RISC**이다. RISC는 Reduced Instruction Set Computer의 약자이다. 이름처럼 RISC는 CISC에 비하여 명령어의 종류가 적다. 그러나 CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.  
즉, RISC는 **고정 길이 명령어**를 활용한다.

명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라이닝에 최적화되어 있다. 또한 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구한다.

RISC는 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용한다. 그렇기에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터의 개수도 더 많다. 다만 사용 가능한 명령어 개수가 CISC보다 적기 때문에 RISC는 CISC보다 더 많은 명령어로 프로그램을 작동시킨다.

ARM은 RISC 기반의 대표적인 ISA이다.

| CISC                                 | RISC                                 |
| ------------------------------------ | ------------------------------------ |
| 복잡하고 다양한 명령어               | 단순하고 적은 명령어                 |
| 가변 길이 명령어                     | 고정 길이 명령어                     |
| 다양한 주소 지정 방식                | 적은 주소 지정 방식                  |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클럭에 걸쳐 명령어 수행         | 1클럭 내외로 명령어 수행             |
| 파이프라이닝하기 어려움              | 파이프라이닝하기 쉬움                |
